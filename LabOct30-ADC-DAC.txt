// Worked on ADC and DAC; October 30th


#include <stdio.h>
#include "diag/Trace.h"
#include "cmsis/cmsis_device.h"


void myADC_Init(){


/* STEP 1: Enable clock for GPIOA peripheral */
// Relevant register: RCC->AHBENR
RCC->APB2ENR |= RCC_APB2ENR_ADCEN;


/* Configure PA5 as analog */
// Relevant register: GPIOA->MODER
/* Configure PA4 as analog */
// Relevant register: GPIOA->MODER
GPIOA->MODER &= (GPIO_MODER_MODER5 | GPIO_MODER_MODER4);




/* STEP 2: ADC1 -> CFGR1 Configuration Register */
ADC1 -> CFGR1 |= (ADC_CFGR1_RES | ADC_CFGR1_ALIGN | ADC_CFGR1_OVRMOD | ADC_CFGR1_CONT);


/* STEP 3: Channel Select (enable bit 5 to 1) ADC1 -> CHSELR[5]=1 */
ADC1 -> CHSELR |= ADC_CHSELR_CHSEL5;


/* STEP 4: ADC1 -> SMPR Sampling Time Register */
ADC1 -> SMPR |= ADC_SMPR_SMP;


/* STEP 5: ADC1 -> CR Control Register */
ADC1 -> CR |= ADC_CR_ADEN;


/* STEP 6: Wait loop for ISR[0] = 1 Interrupt and Status Register (Check for ADC Ready flag) */
while (ADC1 -> ISR[0] != 1){};


}


Int main(int argc, char* argv[])
{
        SystemClock48MHz();
        uint32_t value;


trace_printf("This is ADC and DAC part of Project...\n");
        trace_printf("Value: %u \n", value);


        myADC_Init();                /* Initialize ADC */


        /* CR[2] = 1 */
ADC1 -> CR |= ADC_CR_ADSTART;


/* Wait for ISR[2] = 1 */
while (ADC1 -> ISR[2] != 1){};


/* Value = ADC1-> DR */
value = ADC1 -> DR;


/* Enable clock for DAC */
RCC-> APB1ENR |=RCC_APB1ENR_DACEN;


/* Configure DAC Control Register */
DAC_CR |= DAC_CR_EN1 | DAC_CR_BOFF1 | DAC_CR_TEN1;


/* Send this value to DAC */
DAC-> DH = value;


        while (1)
        {
                // Nothing is going on here...
        }
        return 0;
}